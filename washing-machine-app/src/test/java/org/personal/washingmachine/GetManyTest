Goal:
 Modify public WashingMachine findBySerialNumber(String serialNumber)
 INTO
 public Map<String, WashingMachine> findBySerialNumber(List<String> serialNumbers)

 Ex.: When receiving List.of("serial1", "serial2", "serial3"), should send back:
    Map<"serial1", WashingMachine containing that serial>
    Map<"serial2", WashingMachine containing that serial>
    Map<"serial3", WashingMachine containing that serial>

 Other considerations:
   a. No duplicates should be returned, even if the user sends the same serial number twice => Map already has unique keys.
   b. If no washingMachine with the given serial number is found, it should return Map<"notFound", null>

1. Created GetManyTest class
2. Decided to extend the class with BaseIntegrationTest, as it is easier to test multiple scenarios
3. Added dependencies, applicationService and repository with @Autowired
4. Added @TestInstance(TestInstance.Lifecycle.PER_CLASS) so the @BeforeAll void loadDataInDB() method is executed only once.

5. Created a simple test => assertThat(washingMachineRepository.count()).isEqualTo(5);
6. Started Docker, since we are using TestContainers
7. Run the entire class => no problems
8. Run entire java test package => problems with the other integration tests. The data from the other integration tests conflicts with this one.

9. Added p6spy dependency to see commits and rollbacks
10. Added spy.properties to configure it
11. Found out that @Transactional and @AutoConfigureMockMvc doesn't rollback the @BeforeAll methods
12. For now I used cleanUpDB() with @AfterAll for both integration tests. So the data won't collide anymore.
Point of discussion. Any better way?

13. Create test should_ReturnWashingMachines_When_ProvidedValidSerialNumbers
14. Added blank GIVEN, WHEN, THEN
15. Added List<String> serialNumbers in the GIVEN part
16. Added washingMachineApplicationService.loadMany(serialNumbers);
17. ALT + ENTER to create the method in WashingMachineApplicationService
18. Test is green

19. Store washingMachineApplicationService.loadMany(serialNumbers); into a List<WashingMachine> actual
20. ALT + ENTER to change the return type of the method from void to List<WashingMachine>
21. Write assertion that actual isNotEmpty
22. Test fails because the method returns null
23. Write in loadMany method return repository.findAllBySerialNumberIn(serialNumbers);
24. ALT + ENTER to create the method in the repository
25. Test is green

26. Add .containsExactlyInAnyOrderElementsOf(serialNumbers) to check if the given serialNumbers are found in the washingMachines retrieved from the DB.
27. Test is green
*** Mutation test ***
28. Comment washingMachine with serial1 from loadDataInDB
29. Test fails => not an evergreen one
30. Uncomment washingMachine with serial1 from loadDataInDB
*** Mutation test end ***

31. Create GetManyMvcTest
32. Create test should_ThrowException_When_ListIsNull()
33. Declare variable List<WashingMachine> content = null;
34. Perform request to api/v1/washing-machines/many
35. Test passes, but it is because Request method 'POST' is not supported
36. Create the endpoint in IWashingMachineApplicationService
37. Test is not needed as null is handled by spring via @RequestBody

38. Rename test to should_ThrowException_When_ListIsEmpty()
39. In THEN validate that the status is BAD_REQUEST
40. Test fails
41. Write a guard clause to check the list is empty that throw new CustomException(ErrorCode.LIST_NOT_EMPTY);
42. Add in ErrorCode LIST_NOT_EMPTY (HttpStatus.BAD_REQUEST)
43. Add LIST_NOT_EMPTY = List must not be empty in message.properties and for each locale
44. Test is green

45.